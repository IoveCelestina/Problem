<center> <font size='6'>搜索</front></center>



$\mathbf{\bullet} \quad $ 通过不断地尝试寻找答案的一种算法,通过穷尽所有的可能来找到最优解

$\mathbf{\bullet} \quad $基础的搜索有朴素暴力，深搜，广搜，本次只提及这些

$\mathbf{\bullet} \quad $至于迭代加深，双向广搜，A*等可以之后再学





## DFS

在搜索算法中，通常指利用**递归**实现暴力的枚举算法

在写DFS的时候最好把**退出的条件写在最前面**

### $\mathbf{\bullet} \quad  Eg1:$ 输出 $1-n$ 的全排列

https://ac.nowcoder.com/acm/contest/23156/1001























思路:每一层枚举选择一个未选择的数，然后再递归做相同的事，时间复杂度**O(n!)**

```c++
#include<bits/stdc++.h>
using namespace std;
constexpr int n = 10;

int vis[100],a[100];
void print(){
    for(int i = 1;i<=n;++i){
        printf("%d ",a[i]);
    }
    printf("\n");
}

void dfs(int i){
    for(int j = 1;j<=n;++j){
        if(vis[j]) continue;
        vis[j] = 1;
        a[i] = j;
        if(i==n){
            print();
            return;
        }else{
            dfs(i+1);
        }
        vis[j] = 0;//回溯操作，给explanation
    }
}
signed main(){
    dfs(1);
    return 0;
}
```





### $\mathbf{\bullet} \quad  Eg2:$ 求n个里面选k个的异或和的最大值

https://atcoder.jp/contests/abc386/tasks/abc386_e



























思路:朴素暴力，每一个尝试选或不选，时间复杂度$\binom{n}{k}$ ，此外还可以考虑一些小的优化，如果剩下的个数等于我还需要选的数字个数，那么可以直接全部选上，维护一个后缀异或和即可

```c++
#include<bits/stdc++.h>
using namespace std;
using i64 = long long;
using i128 = __int128;

constexpr int maxn = 2e5+10;
i64 n,K,suf[maxn],a[maxn],ans;
void dfs(int i,int k,i64 x){
    if(k==0){
        ans =max(ans,x);
        return;
    }
    if(i+k-1==n){
        ans = max(ans,x^suf[i]);
        return;
    }
    dfs(i+1,k,x);
    dfs(i+1,k-1,x^a[i]);
}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>K;
    for(int i = 1;i<=n;++i) cin>>a[i];
    for(int i = n;i>=1;--i) suf[i] = suf[i+1]^a[i];
    dfs(1,K,0ll);
    cout<<ans<<"\n";
    return 0;
}
```



## BFS

主要的特点，用队列解决问题，每次用队首转移状态，把新状态加入队尾，直至队列为空



### $\mathbf{\bullet} \quad  Eg1:$ 迷宫问题

链接：https://ac.nowcoder.com/acm/contest/23156/1014



给你一个n*m的迷宫，这个迷宫中有以下几个标识：  

  s代表起点  

  t代表终点  

  x代表障碍物  

  .代表空地  

  现在知了想知道能不能从起点走到终点不碰到障碍物（只能上下左右进行移动，并且不能移动到已经移动过的点）。























思路:从队首开始，往四周开始尝试，知道找到终点或者走过所有能走过的点

```c++
#include<bits/stdc++.h>
using namespace std;
using i64 = long long;
using i128 = __int128;

constexpr int maxn = 500+10;
int n,m;
char mp[maxn][maxn];
bool vis[maxn][maxn];
int dx[4]={0,0,-1,1},dy[4] = {1,-1,0,0};

bool bfs(array<int,2> &s,array<int,2> &t){
    queue<array<int,2>> q;
    q.push(s);
    vis[s[0]][s[1]]=1;
    while(!q.empty()){
        auto tmp = q.front();
        q.pop();
        if(tmp==t) return 1;
        for(int i = 0;i<4;++i){
            int tx = tmp[0]+dx[i],ty = tmp[1]+dy[i];
            if(vis[tx][ty]||tx<1||tx>n||ty<1||ty>m||mp[tx][ty]=='x') continue;
            q.push({tx,ty});
            vis[tx][ty]=1;
        }
    }
    return 0;
}
void solve(){
    cin>>n>>m;
    array<int,2> st,ed;
    for(int i = 1;i<=n;++i){
        for(int j = 1;j<=m;++j){
            vis[i][j]=0;
            cin>>mp[i][j];
            if(mp[i][j]=='s') st={i,j};
            if(mp[i][j]=='t') ed={i,j};
        }
    }
    cout<<(bfs(st,ed)?"YES":"NO")<<"\n";
}

signed main(){
    ios::sync_with_stdio(0);cin.tie(0);
    int t = 1;
    cin>>t;
    while(t--){
        solve();
    }
    return 0;
}
```



当然本题也可以用DFS解决，大家自己尝试解决一下

尝试了不会可以参考以下程序

https://ac.nowcoder.com/acm/contest/view-submission?submissionId=74424974



### $\mathbf{\bullet} \quad  Eg2:$ 寻找联通块的个数

$\mathbf{\bullet}$  联通块是指块内部是可以任取两点是可以相互到达的,块与块之间的点没有边连接







# 图论

